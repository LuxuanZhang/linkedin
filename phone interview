1. nested array, 例如[1,2,[3,4,[5,],7],8,9]，要求一次性输出，直接iterator方法，本来还想着用generator，后来克制住没有作。

2. leetcode 20 Valid Parentheses，中间有个follow up，我一开始的程序是（、【、{逐一判断，大哥说我要是有500个不同的parentheses的表达怎么办？直接dictionary（hashmap）预存啊！

3. given a tree structrue {'s1':'()','s2:{s3:'{}'}','s4':''}, 判断这个given tree是否是valid tree（即里面的元素都是valid parentheses）

4. LC 244

5. Nearest p points of a given center. (最大堆。) 

6.  Maximum Subarray (LC)

7. Shortest Word Distance II (LC)

8. give a string containing ‘a’ to ‘z’, sort lexicographically. Example “ bbdda” - > “abbdd”

9. maximum sum subarray, product array

10. Find the Celebrity(LC)

11. 第一题： public boolean canPlaceFlowers(List flowerbed, int numberToPlace) 如果flowerbed当中为true，说明已经栽过花了，
附近两个不能再栽花。numberToPlace代表想再栽多少花到flowerbed里。让return是不是还能栽那么多谢花进去。 

第二题： public int distance (List words, String wordOne, String wordTwo) 给一个string list，可能存在重复，给两个word，
让return这两个word在list中的最短距离(index distance)  (CC150 chapter 18)
我的做法是维护一个hashmap，key是add进来的数，value是出现的次数。每次检查是否存在的时候遍历hashmap，
然后check当前的key: if (target - currentKey == currentKey && hashmap.get(currentKey) > 1) return true; 
if (hashmap.containsKey(target - currentkey)) { return true; } // else return false; 因为题目并没有要求返回哪两个数，
只要求检查是否存在。

第三题： 输入是一个array stream，在任何时候call你的method，给一个input value，
让返回之前输入过的数字有没有两个加起来等于这个value的（2sum稍稍变形）

12. rotate array

13. Reverse Word in a String II，
Validate Binary Search Tree。

14. Word Ladder I变形，要求输出一条最短路径，一不小心理解成Word Ladder II了，写了一白板code还不够。

15. 1. 有n个学生（编号为sid = ）依次走进有n个锁柜的房间（锁的编号为lockid = )，该学生将会打开或锁上lockid可以被sid整除的锁，
写一个打印所有在第n个学生操作后处于打开的状态的lockid。(完全平方数 builb switcher LC 319)
2. Shortest Word Distance II，需要处理word1和word2相同的情况，并需要注意该情况下list中只有一个word1的case



